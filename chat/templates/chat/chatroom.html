{% extends 'layout.html' %}
{% load static %}
{% load widget_tweaks %}

{% block load_css %}
     <link href="{% static 'chat/main.css' %}" rel="stylesheet">
     <link href="{% static 'css/multi-select.css' %}" rel="stylesheet">
{% endblock load_css %}

{% block content %}
    {% if user_is_admin %}
        <!-- Button trigger settings modal -->
        <button type="button" class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#teamSettingsModal">
            Ustawienia
        </button>

        <!-- Settings Modal -->
        {% comment %} #TODO FORCE: opened group has to have looking_for filled - otherwise causes error in limited_choices var in TeamJoinForm form {% endcomment %}
        <div class="modal fade" id="teamSettingsModal" tabindex="-1" aria-labelledby="teamSettingsModalLabel" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="teamSettingsModalLabel">Ustawienia</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                        <form action="{% url 'chat:update-team-settings' team_id=team_id %}" method="POST">
                            <div class="modal-body">
                                    {% csrf_token %}
                                    <div>
                                        {{ form.our_stack.label_tag }}
                                        {% render_field form.our_stack|attr:"data-multi-select-plugin"%}
                                    </div>
                                    <div>
                                        {{ form.looking_for.label_tag }}
                                        {% render_field form.looking_for|attr:"data-multi-select-plugin"%}
                                    </div>
                                    <div class="form-check form-switch">
                                        {{ form.is_closed.label_tag }}
                                        {% render_field form.is_closed class="form-check-input" %}
                                    </div>
                                
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-dark" data-bs-dismiss="modal">Anuluj</button>
                                <button type="submit" class="btn btn-dark">Zapisz</button>
                            </div>
                        </form>
                    </div>
            </div>
        </div>

        <!-- Button trigger delete team modal -->
        <button type="button" class="btn btn-danger" data-bs-toggle="modal" data-bs-target="#deleteTeamModal">
            Usu≈Ñ dru≈ºynƒô
        </button>

        <!-- Delete Team Modal -->
        <div class="modal fade" id="deleteTeamModal" tabindex="-1" aria-labelledby="deleteTeamModalLabel" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="deleteTeamModalLabel">Jeste≈õ pewien?</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    Ta akcja jest nieodwracalna i bƒôdzie skutkowa≈Ça usuniƒôciem ca≈Çej dru≈ºyny, jej wiadomo≈õci, jak i od≈ÇƒÖczenia jej od og≈Çoszenia. 
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-dark" data-bs-dismiss="modal">Anuluj</button>
                    <form action="{% url 'chat:delete-team' team_id=team_id %}" method="POST">
                        {% csrf_token %}
                        <button type="submit" class="btn btn-danger">Usu≈Ñ</button>
                    </form>
                </div>
                </div>
            </div>
        </div>        
        
        
        <!-- Delete Team Member Modal -->
        <div class="modal fade" id="deleteTeamMemberModal" tabindex="-1" aria-labelledby="deleteTeamMemberModalLabel" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="deleteTeamMemberModalLabel">Jeste≈õ pewien?</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    Ta akcja jest nieodwracalna i bƒôdzie skutkowa≈Ça usuniƒôcie u≈ºytkownika z dru≈ºyny. 
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-dark" data-bs-dismiss="modal">Anuluj</button>
                    <form action="{% url 'chat:delete-team-member' team_id=team_id %}" method="POST">
                        {% csrf_token %}
                        <input type="hidden" name="member-id" class="js-delete-member-input">
                        <button type="submit" class="btn btn-danger">Usu≈Ñ</button>
                    </form>
                </div>
                </div>
            </div>
        </div>
    {% endif %}


    <div class="container mt-5">
        <div class="row d-flex justify-content-center">
            <div class="col-6">
                <div class="h4">Chatroom dla {{ organization }}</div>
                <div class="form-control chat-window chat-window-js">
                    <ul id="message-list">
                    </ul>
                </div>
                <input class="form-control msg-field-js" type="text"></br>
                <input class="btn btn-secondary btn-lg btn-block" id="submit" type="button" value="Send" disabled>
            </div>
            <div class="col-6">
                <div class="h4">Uczestnicy</div>
                <ul>
                    {% for member in members %}
                        {% comment %} #TODO dont show not joined users {% endcomment %}
                        <li {% if member.is_admin %}style='color:red'{% endif %}>{{ member.nick }} - {{ member.get_role_display }} 
                            {% if not member.is_admin and user_is_admin %}
                                <!-- Button trigger delete team member modal -->        
                                <button type="button" class="btn btn-danger js-delete-member" data-bs-toggle="modal" data-bs-target="#deleteTeamMemberModal" data-member-id="{{ member.id }}">
                                    X
                                </button>
                            {% endif %}</li> 
                    {% endfor %}
                </ul>
            </div>
        </div>
    </div>

    <script src="{% static 'js/multi-select.js' %}"></script>
    <script>
        function deleteModelControl() {
            const deleteButtons = document.querySelectorAll('.js-delete-member');
            const modalDeleteMembetInput = document.querySelector('.js-delete-member-input');

            deleteButtons.forEach(btn => btn.addEventListener('click', function (e) {
                // Get member's ID
                const memberId = this.dataset.memberId;

                // Inject it to the modal
                modalDeleteMembetInput.value = memberId;
            }));
        }
        deleteModelControl();
    </script>
    <script>
        //{% comment %} #TODO disable multiselects in settings if group closed - add tooltip or smth {% endcomment %}
    </script>
    <script>
        const currentUser  = '{{ request.user.email }}';
        const chatWindow = document.querySelector('.chat-window-js');
        const messageInput = document.querySelector('.msg-field-js');
        const submitButton = document.querySelector('#submit');
        let msgPageToLoad = 1;
        let loadingMsgsFlag = false;

        function appendNewMsg(data, loadedMsgs=false) {
            const messageList = document.querySelector('#message-list');
            //#TODO set position ass li class (current user or other users - right, left)
            //#TODO use nick instead of email
            const position = (data.sender === currentUser) ? 'right' : 'left'
            const newMsg = document.createElement("li");
            newMsg.innerHTML = `<li>${data.sender}: ${data.content}</li>`;

            // When loading msgs from db add to the start of the chat
            // otherwise (websocket msgs) ass to the end of the chat
            if (loadedMsgs) {
                messageList.prepend(newMsg)
            }
            else {
                messageList.append(newMsg)
            }
        }

        function sendMsg(event){
            const message = messageInput.value;
            // Send to websocket
            socket.send(JSON.stringify({
                'msg_type': 'message',
                'content': message,
                'sender': currentUser
            }));
            messageInput.value = '';
        }

        function configureWebSocket(){
            // Configure new WebSocket
            const loc = window.location;
            let wsStart = (loc.protocol === 'https:') ? 'wss://' : 'ws://'
            const endpoint = wsStart + loc.host + loc.pathname + '/'

            const socket = new WebSocket(endpoint);

            // Configure events
            // Receive from websocket
            socket.onmessage = function (e) {
                const data = JSON.parse(e.data);
                appendNewMsg(data);
                scrollToChatPosition(percentage=100);
            }

            socket.onopen = function (e) {
                console.log('open', e)
                //#TODO make user icon online when connection opened
                loadMessages(initialLoad=true);
            }
            socket.onclose = function (e) {
                console.log('close', e)
                //#TODO make user icon offline when connection closed
            }
            socket.onerror = function (e) {
                console.log('error', e)
            }

            return socket
        }

        // Fetches single page of msgs and returns them
        function fetchMessages(){
            const endpoint = window.location.href + '/wiadomosci'

            return fetch(endpoint + `?page=${msgPageToLoad}`)
                    .then(response => {
                        if (response.ok) {
                            return response.json();
                        }
                        throw new Error('Fetching messages failed!');
                    })
                    .then(msgPage => {
                        // If all msgs loaded - disable load msgs functionality
                        if (msgPageToLoad >= msgPage.numPages) {
                            console.info('All messages loaded')
                            chatWindow.removeEventListener('scroll', handleScrollMsgs)
                        }
                        else {
                            msgPageToLoad++;
                        }
                        return msgPage;
                    })
                    .catch(err => console.log(err))
        }

        // Loads single page of msgs and inserts them to DOM
        //#TODO add loading spinner
        function loadMessages(initialLoad=false){
            loadingMsgsFlag = true;
            fetchMessages()
            .then(msgPage => {
                //console.log(msgPage)
                msgPage.data.forEach(msg => {
                    appendNewMsg(msg, true)
                })
                // For first load - scroll to the bottom
                // For other - scroll only a little
                initialLoad ? scrollToChatPosition(percentage=100) : scrollToChatPosition(percentage=25)

                loadingMsgsFlag = false;
            })
        }

        function scrollToChatPosition(percentage) {
            chatWindow.scrollTop = chatWindow.scrollHeight * (percentage/100);
        }

        // When users scrolls to the top of the chat window load more msgs
        function handleScrollMsgs(){        
            if (this.scrollTop < 30 && !loadingMsgsFlag) {
                loadMessages()   
            }
        }

        function handleEnterPressed(event) {
            if (event.key === 'Enter' && !submitButton.disabled) {
                submitButton.click()
            }
        }

        const socket = configureWebSocket();        
        // When user is not typing - disable submit button
        messageInput.addEventListener('keyup', (e) => {
            submitButton.disabled = e.target.value ? false : true
        })
        document.addEventListener("keyup", e => handleEnterPressed(e));
        submitButton.addEventListener('click', sendMsg);
        chatWindow.addEventListener('scroll', handleScrollMsgs)
        /*
        function debounce(func, wait, immediate) {
            var timeout;
            return function() {
                var context = this, args = arguments;
                var later = function() {
                    timeout = null;
                    if (!immediate) func.apply(context, args);
                };
                var callNow = immediate && !timeout;
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
                if (callNow) func.apply(context, args);
            };
        };
        */
    </script>


{% comment %} 
    <li {% if member.is_admin %}style='color:red'{% endif %}>{{ member.creator }} - {{ member.get_role_display }} <span id="user-{{ member.creator.user.id }}-status">üî¥</span></li>

    const currentUserId  = '{{ request.user.id }}';

    socket.onmessage = function (e) {
        const data = JSON.parse(e.data);
        console.log(data)
        if (data['msg_type'] === 'message') {
            appendNewMsg(data);
            scrollToChatPosition(percentage=100);
        }
        else if (data['msg_type'] === 'user_status') {
            const creatorNode = document.querySelector('#user-' + data['user_id'] + '-status')
            creatorNode.innerHTML = data['status'] === 'online' ? 'üü¢' : 'üî¥' 
        }
    }

    socket.onopen = function (e) {
        console.log('open', e)
        //#TODO make user icon online when connection opened
        loadMessages(initialLoad=true);
        socket.send(JSON.stringify({
            'msg_type': 'user_status',
            'user_id': currentUserId,
            'status': 'online'
        }));
    }
    socket.onclose = function (e) {
        console.log('close', e)
        //#TODO make user icon offline when connection closed
        socket.send(JSON.stringify({
            'msg_type': 'user_status',
            'user_id': currentUserId,
            'status': 'offline'
        }));
    } 
{% endcomment %}
{% endblock content %}
